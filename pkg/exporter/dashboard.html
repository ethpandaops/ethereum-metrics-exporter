<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ethereum Metrics Exporter</title>
    <style>
        /* EMBEDDED_CSS */
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.30.0/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>Ethereum Metrics Exporter</h1>

        <div class="info-banner">
            <div class="info-content">
                <span class="info-text">Raw Prometheus metrics available at:</span>
                <a href="/metrics" target="_blank" class="metrics-link">/metrics</a>
            </div>
        </div>

        <div class="controls">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Search metrics... (e.g., block, sync, peer)">
                <div class="help-text">Filter metrics by name or labels</div>
            </div>
            <div class="status">
                <span class="status-indicator" id="statusIndicator"></span>
                <span id="statusText">Connecting...</span>
                <span id="lastUpdate"></span>
                <span>| Next update in: <span class="countdown" id="countdown">15s</span></span>
            </div>
        </div>

        <div class="tabs" id="tabs" style="display: none;">
            <button class="tab-button active" data-tab="all">All</button>
            <button class="tab-button" data-tab="execution">Execution</button>
            <button class="tab-button" data-tab="consensus">Consensus</button>
            <button class="tab-button" data-tab="others">Others</button>
            <div class="tab-counts">
                <span id="count-all" class="tab-count"></span>
                <span id="count-execution" class="tab-count"></span>
                <span id="count-consensus" class="tab-count"></span>
                <span id="count-others" class="tab-count"></span>
            </div>
        </div>

        <div id="loading" class="loading">Loading metrics...</div>
        <div id="error" class="error" style="display: none;"></div>
        <div id="noData" class="no-data" style="display: none;">No metrics found matching your search.</div>
        <div id="metricsGrid" class="metrics-grid" style="display: none;"></div>

        <footer class="footer">
            Powered by üêº <a href="https://github.com/ethpandaops/ethereum-metrics-exporter" target="_blank">ethpandaops/ethereum-metrics-exporter</a>
        </footer>
    </div>

    <script>
        const REFRESH_INTERVAL = 15000; // 15 seconds
        const MAX_DATA_POINTS = 20;
        const metrics = new Map();
        let charts = new Map();
        let updateTimer;
        let countdownTimer;
        let secondsUntilUpdate = 15;
        let activeTab = 'all';

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            fetchMetrics();
            startCountdown();
            updateTimer = setInterval(() => {
                fetchMetrics();
                startCountdown();
            }, REFRESH_INTERVAL);

            // Search functionality
            document.getElementById('searchInput').addEventListener('input', filterMetrics);

            // Tab functionality
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', () => {
                    setActiveTab(button.dataset.tab);
                });
            });
        });

        function setActiveTab(tab) {
            activeTab = tab;
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tab);
            });
            renderMetrics();
        }

        function getMetricCategory(metricName) {
            if (metricName.startsWith('eth_exe_')) return 'execution';
            if (metricName.startsWith('eth_con_')) return 'consensus';
            if (metricName.startsWith('eth_docker_')) return 'others';
            return 'others';
        }

        function parseLabels(labelsString) {
            const labels = [];
            const regex = /(\w+)="([^"]*)"/g;
            let match;

            while ((match = regex.exec(labelsString)) !== null) {
                labels.push({ key: match[1], value: match[2] });
            }

            return labels;
        }

        function createLabelsContainer(labelsString, metricKey) {
            const container = document.createElement('div');
            container.className = 'metric-labels';

            const labels = parseLabels(labelsString);

            labels.forEach(label => {
                const labelEl = document.createElement('div');
                labelEl.className = 'metric-label';
                labelEl.innerHTML = `<span class="label-key">${label.key}:</span><span class="label-value">${label.value}</span>`;
                container.appendChild(labelEl);
            });

            return container;
        }

        function startCountdown() {
            secondsUntilUpdate = 15;
            updateCountdownDisplay();

            // Clear existing countdown if any
            if (countdownTimer) clearInterval(countdownTimer);

            countdownTimer = setInterval(() => {
                secondsUntilUpdate--;
                updateCountdownDisplay();

                if (secondsUntilUpdate <= 0) {
                    clearInterval(countdownTimer);
                }
            }, 1000);
        }

        function updateCountdownDisplay() {
            const countdownEl = document.getElementById('countdown');
            if (countdownEl) {
                countdownEl.textContent = `${secondsUntilUpdate}s`;
            }
        }

        async function fetchMetrics() {
            try {
                const response = await fetch('/metrics');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

                const text = await response.text();
                parseMetrics(text);
                updateStatus('Connected', true);
                renderMetrics();

                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'none';
                document.getElementById('metricsGrid').style.display = 'grid';
            } catch (error) {
                console.error('Error fetching metrics:', error);
                updateStatus('Error', false);
                document.getElementById('error').textContent = `Error: ${error.message}`;
                document.getElementById('error').style.display = 'block';
            }
        }

        function parseMetrics(text) {
            const lines = text.split('\n');
            const timestamp = Date.now();
            const currentMetrics = new Set();

            for (const line of lines) {
                if (line.startsWith('#') || line.trim() === '') continue;

                const match = line.match(/^([a-zA-Z_][a-zA-Z0-9_]*(?:\{[^}]*\})?)\s+([\d\.\+\-eE]+|NaN|Inf|-Inf)$/);
                if (!match) continue;

                const [, nameWithLabels, value] = match;
                const labelMatch = nameWithLabels.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\{([^}]*)\}$/);

                let metricName, labels;
                if (labelMatch) {
                    metricName = labelMatch[1];
                    labels = labelMatch[2];
                } else {
                    metricName = nameWithLabels;
                    labels = '';
                }

                const metricKey = nameWithLabels;
                const numericValue = parseFloat(value);
                currentMetrics.add(metricKey);

                if (!metrics.has(metricKey)) {
                    metrics.set(metricKey, {
                        name: metricName,
                        labels: labels,
                        data: [],
                        currentValue: numericValue,
                        lastUpdate: timestamp
                    });
                }

                const metric = metrics.get(metricKey);
                metric.currentValue = numericValue;

                // Always add a new data point for each fetch
                metric.data.push({ x: timestamp, y: numericValue });

                // Keep only last MAX_DATA_POINTS
                if (metric.data.length > MAX_DATA_POINTS) {
                    metric.data.shift();
                }
            }

            // Remove metrics that are no longer being reported
            for (const [key] of metrics) {
                if (!currentMetrics.has(key)) {
                    metrics.delete(key);
                }
            }
        }

        function renderMetrics() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const grid = document.getElementById('metricsGrid');

            // First, count all metrics by category
            const counts = { all: 0, execution: 0, consensus: 0, others: 0 };
            metrics.forEach((metric) => {
                const category = getMetricCategory(metric.name);
                counts.all++;
                counts[category]++;
            });

            // Then filter for display
            const visibleMetrics = Array.from(metrics.entries())
                .filter(([key, metric]) => {
                    const category = getMetricCategory(metric.name);

                    // Filter by search term
                    const matchesSearch = searchTerm === '' ||
                                        key.toLowerCase().includes(searchTerm) ||
                                        metric.labels.toLowerCase().includes(searchTerm);

                    // Filter by active tab
                    const matchesTab = activeTab === 'all' || category === activeTab;

                    // Both search and tab filters must match
                    return matchesSearch && matchesTab;
                })
                .sort((a, b) => a[0].localeCompare(b[0]));

            // Update tab counts
            updateTabCounts(counts);

            // Show/hide tabs based on whether we have metrics
            document.getElementById('tabs').style.display = metrics.size > 0 ? 'flex' : 'none';

            // Show/hide no data message
            document.getElementById('noData').style.display = visibleMetrics.length === 0 ? 'block' : 'none';

            visibleMetrics.forEach(([key, metric]) => {
                let card = document.getElementById(`metric-${key.replace(/[^a-zA-Z0-9]/g, '_')}`);

                if (!card) {
                    card = createMetricCard(key, metric);
                    grid.appendChild(card);
                } else {
                    updateMetricCard(card, key, metric);
                }
            });

            // Remove cards for metrics that are no longer visible
            Array.from(grid.children).forEach(card => {
                const cardKey = card.dataset.metricKey;
                if (!visibleMetrics.find(([key]) => key === cardKey)) {
                    const chartId = `chart-${cardKey.replace(/[^a-zA-Z0-9]/g, '_')}`;
                    if (charts.has(chartId)) {
                        const chart = charts.get(chartId);
                        chart.destroy();
                        charts.delete(chartId);
                    }
                    card.remove();
                }
            });
        }

        function createMetricCard(key, metric) {
            const card = document.createElement('div');
            card.className = 'metric-card';
            card.id = `metric-${key.replace(/[^a-zA-Z0-9]/g, '_')}`;
            card.dataset.metricKey = key;

            const header = document.createElement('div');
            header.className = 'metric-header';

            const name = document.createElement('div');
            name.className = 'metric-name';
            name.textContent = metric.name;

            const value = document.createElement('div');
            value.className = 'metric-value';
            value.textContent = formatValue(metric.currentValue);

            header.appendChild(name);
            header.appendChild(value);
            card.appendChild(header);

            if (metric.labels) {
                const labelsContainer = createLabelsContainer(metric.labels, key);
                card.appendChild(labelsContainer);
            }

            const chartContainer = document.createElement('div');
            chartContainer.className = 'metric-chart';
            const canvas = document.createElement('canvas');
            canvas.id = `chart-${key.replace(/[^a-zA-Z0-9]/g, '_')}`;
            chartContainer.appendChild(canvas);
            card.appendChild(chartContainer);

            // Create chart after adding to DOM
            setTimeout(() => {
                if (!charts.has(canvas.id)) {
                    createChart(canvas.id, metric);
                }
            }, 10);

            return card;
        }

        function updateMetricCard(card, key, metric) {
            const value = card.querySelector('.metric-value');
            value.textContent = formatValue(metric.currentValue);

            const chartId = `chart-${key.replace(/[^a-zA-Z0-9]/g, '_')}`;
            if (charts.has(chartId)) {
                updateChart(chartId, metric);
            } else {
                // Chart might not exist yet, try to create it
                const canvas = document.getElementById(chartId);
                if (canvas && !charts.has(chartId)) {
                    createChart(chartId, metric);
                }
            }
        }

        function createChart(canvasId, metric) {
            // Check if chart already exists
            if (charts.has(canvasId)) {
                console.warn(`Chart ${canvasId} already exists, updating instead`);
                updateChart(canvasId, metric);
                return;
            }

            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        data: metric.data,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointBackgroundColor: '#667eea',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 1,
                        pointHoverRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: (context) => {
                                    const timestamp = context[0].parsed.x;
                                    return new Date(timestamp).toLocaleTimeString();
                                },
                                label: (context) => `Value: ${formatValue(context.parsed.y)}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            display: true,
                            time: {
                                displayFormats: {
                                    second: 'HH:mm:ss',
                                    minute: 'HH:mm'
                                }
                            },
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxTicksLimit: 4,
                                font: { size: 10 },
                                color: '#999'
                            }
                        },
                        y: {
                            display: true,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            },
                            ticks: {
                                callback: (value) => formatValue(value),
                                maxTicksLimit: 4,
                                font: { size: 10 }
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });

            charts.set(canvasId, chart);
        }

        function updateChart(chartId, metric) {
            const chart = charts.get(chartId);
            if (!chart) return;

            // Update the chart data
            chart.data.datasets[0].data = [...metric.data];
            chart.update();
        }

        function formatValue(value) {
            if (isNaN(value)) return 'NaN';
            if (!isFinite(value)) return value > 0 ? 'Inf' : '-Inf';

            const absValue = Math.abs(value);
            if (absValue >= 1e9) return (value / 1e9).toFixed(2) + 'B';
            if (absValue >= 1e6) return (value / 1e6).toFixed(2) + 'M';
            if (absValue >= 1e3) return (value / 1e3).toFixed(2) + 'K';
            if (absValue < 0.01 && absValue > 0) return value.toExponential(2);
            return value.toFixed(2);
        }

        function filterMetrics() {
            renderMetrics();
        }

        function updateTabCounts(counts) {
            document.querySelectorAll('.tab-button').forEach(button => {
                const tab = button.dataset.tab;
                const count = counts[tab] || 0;
                button.textContent = button.textContent.split(' (')[0] + (count > 0 ? ` (${count})` : '');
            });
        }

        function updateStatus(status, isConnected) {
            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const lastUpdate = document.getElementById('lastUpdate');

            statusText.textContent = status;
            indicator.style.background = isConnected ? '#4caf50' : '#ff5252';
            lastUpdate.textContent = `| Last update: ${new Date().toLocaleTimeString()}`;
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (updateTimer) clearInterval(updateTimer);
            if (countdownTimer) clearInterval(countdownTimer);
            charts.forEach(chart => chart.destroy());
        });
    </script>
</body>
</html>
