<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ethereum Metrics Exporter</title>
    <style>
        /* EMBEDDED_CSS */
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.30.0/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>Ethereum Metrics Exporter</h1>

        <div class="info-banner">
            <div class="info-content">
                <span class="info-text">Raw Prometheus metrics available at:</span>
                <a href="/metrics" target="_blank" class="metrics-link">/metrics</a>
            </div>
        </div>

        <div class="controls">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Search metrics... (e.g., block, sync, peer)">
                <div class="help-text">Filter metrics by name or labels</div>
            </div>
            <div class="status">
                <span class="status-indicator" id="statusIndicator"></span>
                <span id="statusText">Connecting...</span>
                <span id="lastUpdate"></span>
                <span>| Next update in: <span class="countdown" id="countdown">15s</span></span>
            </div>
        </div>

        <div class="tabs" id="tabs" style="display: none;">
            <button class="tab-button active" data-tab="all">All</button>
            <button class="tab-button" data-tab="execution">Execution</button>
            <button class="tab-button" data-tab="consensus">Consensus</button>
            <button class="tab-button" data-tab="docker">Docker</button>
            <button class="tab-button" data-tab="disk">Disk</button>
            <button class="tab-button" data-tab="others">Others</button>
            <div class="tab-counts">
                <span id="count-all" class="tab-count"></span>
                <span id="count-execution" class="tab-count"></span>
                <span id="count-consensus" class="tab-count"></span>
                <span id="count-docker" class="tab-count"></span>
                <span id="count-disk" class="tab-count"></span>
                <span id="count-others" class="tab-count"></span>
            </div>
        </div>

        <div id="loading" class="loading">Loading metrics...</div>
        <div id="error" class="error" style="display: none;"></div>
        <div id="noData" class="no-data" style="display: none;">No metrics found matching your search.</div>
        <div id="metricsGrid" class="metrics-grid" style="display: none;"></div>

        <footer class="footer">
            Powered by üêº <a href="https://github.com/ethpandaops/ethereum-metrics-exporter" target="_blank">ethpandaops/ethereum-metrics-exporter</a>
        </footer>
    </div>

    <script>
        const REFRESH_INTERVAL = 15000; // 15 seconds
        const MAX_DATA_POINTS = 20;
        const metrics = new Map();
        let charts = new Map();
        let updateTimer;
        let countdownTimer;
        let secondsUntilUpdate = 15;
        let activeTab = 'all';

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            fetchMetrics();
            startCountdown();
            updateTimer = setInterval(() => {
                fetchMetrics();
                startCountdown();
            }, REFRESH_INTERVAL);

            // Search functionality
            document.getElementById('searchInput').addEventListener('input', filterMetrics);

            // Tab functionality
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', () => {
                    setActiveTab(button.dataset.tab);
                });
            });
        });

        function setActiveTab(tab) {
            activeTab = tab;
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tab);
            });
            renderMetrics();
        }

        function getMetricCategory(metricName) {
            if (metricName.startsWith('eth_exe_')) return 'execution';
            if (metricName.startsWith('eth_con_')) return 'consensus';
            if (metricName.startsWith('eth_docker_')) return 'docker';
            if (metricName.startsWith('eth_disk_')) return 'disk';
            return 'others';
        }

        function getMetricTypeDescription(type) {
            const descriptions = {
                'counter': 'COUNTER: A cumulative metric that only increases over time (e.g., total requests, errors). Resets only on restart.',
                'gauge': 'GAUGE: A metric that can go up or down (e.g., temperature, memory usage, active connections).',
                'histogram': 'HISTOGRAM: Samples observations and counts them in configurable buckets (e.g., request durations, response sizes).',
                'summary': 'SUMMARY: Similar to histogram but calculates quantiles over a sliding time window (e.g., 95th percentile latency).',
                'untyped': 'UNTYPED: A metric without a specific type. Behavior depends on the metric implementation.'
            };
            return descriptions[type.toLowerCase()] || `${type.toUpperCase()}: Metric type`;
        }

        function parseLabels(labelsString) {
            const labels = [];
            const regex = /(\w+)="([^"]*)"/g;
            let match;

            while ((match = regex.exec(labelsString)) !== null) {
                labels.push({ key: match[1], value: match[2] });
            }

            return labels;
        }

        function createLabelsContainer(labelsString, metricKey) {
            const container = document.createElement('div');
            container.className = 'metric-labels';

            const labels = parseLabels(labelsString);
            const { labelFilters, textSearch } = getActiveSearchTerms();

            labels.forEach(label => {
                const labelEl = document.createElement('div');
                
                // Check if this label matches any active filter
                const isHighlighted = labelFilters.some(filter => 
                    filter.key === label.key && filter.value === label.value
                );
                
                // Check if text search matches label
                const textMatches = textSearch && (
                    label.key.toLowerCase().includes(textSearch) ||
                    label.value.toLowerCase().includes(textSearch)
                );
                
                labelEl.className = 'metric-label clickable-label' + 
                    (isHighlighted ? ' label-highlighted' : '') +
                    (textMatches ? ' label-text-match' : '');
                
                // Highlight matching text
                const keyHtml = textSearch ? highlightText(label.key, textSearch) : label.key;
                const valueHtml = textSearch ? highlightText(label.value, textSearch) : label.value;
                
                labelEl.innerHTML = `<span class="label-key">${keyHtml}:</span><span class="label-value">${valueHtml}</span>`;
                labelEl.title = `Click to filter by ${label.key}="${label.value}"`;
                
                // Add click handler to filter by this label
                labelEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    addLabelToSearch(label.key, label.value);
                });
                
                container.appendChild(labelEl);
            });

            return container;
        }

        function highlightText(text, searchTerm) {
            if (!searchTerm || searchTerm.trim() === '') return text;
            
            const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`(${escapedTerm})`, 'gi');
            return text.replace(regex, '<span class="search-highlight">$1</span>');
        }

        function getActiveSearchTerms() {
            const searchInput = document.getElementById('searchInput');
            const searchTerm = searchInput.value.toLowerCase();
            
            // Extract label filters and plain text
            const labelFilterRegex = /(\w+)="([^"]*)"/g;
            const labelFilters = [];
            let searchWithoutLabels = searchTerm;
            
            let match;
            while ((match = labelFilterRegex.exec(searchTerm)) !== null) {
                labelFilters.push({ key: match[1], value: match[2] });
                searchWithoutLabels = searchWithoutLabels.replace(match[0], '').trim();
            }
            
            return { labelFilters, textSearch: searchWithoutLabels };
        }

        function addLabelToSearch(key, value) {
            const searchInput = document.getElementById('searchInput');
            const labelFilter = `${key}="${value}"`;
            
            // Check if this label filter already exists
            if (!searchInput.value.includes(labelFilter)) {
                // Add to existing search with a space if there's already content
                if (searchInput.value.trim()) {
                    searchInput.value += ' ' + labelFilter;
                } else {
                    searchInput.value = labelFilter;
                }
            }
            
            // Trigger the filter
            filterMetrics();
            
            // Flash the search box to indicate the filter was added
            searchInput.classList.add('search-flash');
            setTimeout(() => {
                searchInput.classList.remove('search-flash');
            }, 300);
        }

        function startCountdown() {
            secondsUntilUpdate = 15;
            updateCountdownDisplay();

            // Clear existing countdown if any
            if (countdownTimer) clearInterval(countdownTimer);

            countdownTimer = setInterval(() => {
                secondsUntilUpdate--;
                updateCountdownDisplay();

                if (secondsUntilUpdate <= 0) {
                    clearInterval(countdownTimer);
                }
            }, 1000);
        }

        function updateCountdownDisplay() {
            const countdownEl = document.getElementById('countdown');
            if (countdownEl) {
                countdownEl.textContent = `${secondsUntilUpdate}s`;
            }
        }

        async function fetchMetrics() {
            try {
                const response = await fetch('/metrics');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

                const text = await response.text();
                parseMetrics(text);
                updateStatus('Connected', true);
                renderMetrics();

                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'none';
                document.getElementById('metricsGrid').style.display = 'grid';
            } catch (error) {
                console.error('Error fetching metrics:', error);
                updateStatus('Error', false);
                document.getElementById('error').textContent = `Error: ${error.message}`;
                document.getElementById('error').style.display = 'block';
            }
        }

        function parseMetrics(text) {
            const lines = text.split('\n');
            const timestamp = Date.now();
            const currentMetrics = new Set();
            const metadataMap = new Map(); // Store HELP and TYPE metadata

            // First pass: collect metadata
            for (const line of lines) {
                if (line.startsWith('# HELP ')) {
                    const helpMatch = line.match(/^# HELP ([a-zA-Z_][a-zA-Z0-9_]*) (.*)$/);
                    if (helpMatch) {
                        const [, metricName, helpText] = helpMatch;
                        if (!metadataMap.has(metricName)) {
                            metadataMap.set(metricName, {});
                        }
                        metadataMap.get(metricName).help = helpText;
                    }
                } else if (line.startsWith('# TYPE ')) {
                    const typeMatch = line.match(/^# TYPE ([a-zA-Z_][a-zA-Z0-9_]*) (.*)$/);
                    if (typeMatch) {
                        const [, metricName, metricType] = typeMatch;
                        if (!metadataMap.has(metricName)) {
                            metadataMap.set(metricName, {});
                        }
                        metadataMap.get(metricName).type = metricType;
                    }
                }
            }

            // Second pass: parse metrics
            for (const line of lines) {
                if (line.startsWith('#') || line.trim() === '') continue;

                const match = line.match(/^([a-zA-Z_][a-zA-Z0-9_]*(?:\{[^}]*\})?)\s+([\d\.\+\-eE]+|NaN|Inf|-Inf)$/);
                if (!match) continue;

                const [, nameWithLabels, value] = match;
                const labelMatch = nameWithLabels.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\{([^}]*)\}$/);

                let metricName, labels;
                if (labelMatch) {
                    metricName = labelMatch[1];
                    labels = labelMatch[2];
                } else {
                    metricName = nameWithLabels;
                    labels = '';
                }

                const metricKey = nameWithLabels;
                const numericValue = parseFloat(value);
                currentMetrics.add(metricKey);

                if (!metrics.has(metricKey)) {
                    const metadata = metadataMap.get(metricName) || {};
                    metrics.set(metricKey, {
                        name: metricName,
                        labels: labels,
                        data: [],
                        currentValue: numericValue,
                        lastUpdate: timestamp,
                        help: metadata.help || '',
                        type: metadata.type || ''
                    });
                }

                const metric = metrics.get(metricKey);
                metric.currentValue = numericValue;

                // Always add a new data point for each fetch
                metric.data.push({ x: timestamp, y: numericValue });

                // Keep only last MAX_DATA_POINTS
                if (metric.data.length > MAX_DATA_POINTS) {
                    metric.data.shift();
                }
            }

            // Remove metrics that are no longer being reported
            for (const [key] of metrics) {
                if (!currentMetrics.has(key)) {
                    metrics.delete(key);
                }
            }
        }

        function renderMetrics() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const grid = document.getElementById('metricsGrid');

            // First, count all metrics by category
            const counts = { all: 0, execution: 0, consensus: 0, docker: 0, disk: 0, others: 0 };
            metrics.forEach((metric) => {
                const category = getMetricCategory(metric.name);
                counts.all++;
                counts[category]++;
            });

            // Then filter for display
            const visibleMetrics = Array.from(metrics.entries())
                .filter(([key, metric]) => {
                    const category = getMetricCategory(metric.name);

                    // Parse search terms - support both simple text and label filters
                    let matchesSearch = true;
                    if (searchTerm !== '') {
                        // Extract label filters (key="value") from search
                        const labelFilterRegex = /(\w+)="([^"]*)"/g;
                        const labelFilters = [];
                        let searchWithoutLabels = searchTerm;
                        
                        let match;
                        while ((match = labelFilterRegex.exec(searchTerm)) !== null) {
                            labelFilters.push({ key: match[1], value: match[2] });
                            searchWithoutLabels = searchWithoutLabels.replace(match[0], '').trim();
                        }
                        
                        // Check text search (metric name)
                        if (searchWithoutLabels) {
                            matchesSearch = key.toLowerCase().includes(searchWithoutLabels) ||
                                          metric.labels.toLowerCase().includes(searchWithoutLabels);
                        }
                        
                        // Check label filters
                        if (labelFilters.length > 0) {
                            const metricLabels = parseLabels(metric.labels);
                            for (const filter of labelFilters) {
                                const hasMatchingLabel = metricLabels.some(label => 
                                    label.key === filter.key && label.value === filter.value
                                );
                                if (!hasMatchingLabel) {
                                    matchesSearch = false;
                                    break;
                                }
                            }
                        }
                    }

                    // Filter by active tab
                    const matchesTab = activeTab === 'all' || category === activeTab;

                    // Both search and tab filters must match
                    return matchesSearch && matchesTab;
                })
                .sort((a, b) => a[0].localeCompare(b[0]));

            // Update tab counts
            updateTabCounts(counts);

            // Show/hide tabs based on whether we have metrics
            document.getElementById('tabs').style.display = metrics.size > 0 ? 'flex' : 'none';

            // Show/hide no data message
            document.getElementById('noData').style.display = visibleMetrics.length === 0 ? 'block' : 'none';

            visibleMetrics.forEach(([key, metric]) => {
                let card = document.getElementById(`metric-${key.replace(/[^a-zA-Z0-9]/g, '_')}`);

                if (!card) {
                    card = createMetricCard(key, metric);
                    grid.appendChild(card);
                } else {
                    updateMetricCard(card, key, metric);
                }
            });

            // Remove cards for metrics that are no longer visible
            Array.from(grid.children).forEach(card => {
                const cardKey = card.dataset.metricKey;
                if (!visibleMetrics.find(([key]) => key === cardKey)) {
                    const chartId = `chart-${cardKey.replace(/[^a-zA-Z0-9]/g, '_')}`;
                    if (charts.has(chartId)) {
                        const chart = charts.get(chartId);
                        chart.destroy();
                        charts.delete(chartId);
                    }
                    card.remove();
                }
            });
        }

        function createMetricCard(key, metric) {
            const card = document.createElement('div');
            card.className = 'metric-card';
            card.id = `metric-${key.replace(/[^a-zA-Z0-9]/g, '_')}`;
            card.dataset.metricKey = key;

            const header = document.createElement('div');
            header.className = 'metric-header';

            const name = document.createElement('div');
            name.className = 'metric-name';
            
            // Highlight metric name if it matches search
            const { textSearch } = getActiveSearchTerms();
            if (textSearch && metric.name.toLowerCase().includes(textSearch)) {
                name.innerHTML = highlightText(metric.name, textSearch);
            } else {
                name.textContent = metric.name;
            }

            const value = document.createElement('div');
            value.className = 'metric-value';
            value.textContent = formatValue(metric.currentValue);

            header.appendChild(name);
            header.appendChild(value);
            card.appendChild(header);

            // Add metadata (HELP and TYPE) if available
            if (metric.help || metric.type) {
                const metadataContainer = document.createElement('div');
                metadataContainer.className = 'metric-metadata';
                
                if (metric.type) {
                    const typeElement = document.createElement('div');
                    typeElement.className = 'metric-type';
                    typeElement.innerHTML = `TYPE: <span class="metric-type-value" data-tooltip="${getMetricTypeDescription(metric.type)}">${metric.type}</span>`;
                    metadataContainer.appendChild(typeElement);
                }
                
                if (metric.help) {
                    const helpElement = document.createElement('div');
                    helpElement.className = 'metric-help';
                    helpElement.textContent = metric.help;
                    metadataContainer.appendChild(helpElement);
                }
                
                card.appendChild(metadataContainer);
            }

            if (metric.labels) {
                const labelsContainer = createLabelsContainer(metric.labels, key);
                card.appendChild(labelsContainer);
            }

            const chartContainer = document.createElement('div');
            chartContainer.className = 'metric-chart';
            const canvas = document.createElement('canvas');
            canvas.id = `chart-${key.replace(/[^a-zA-Z0-9]/g, '_')}`;
            chartContainer.appendChild(canvas);
            card.appendChild(chartContainer);

            // Create chart after adding to DOM
            setTimeout(() => {
                if (!charts.has(canvas.id)) {
                    createChart(canvas.id, metric);
                }
            }, 10);

            return card;
        }

        function updateMetricCard(card, key, metric) {
            // Update metric value
            const value = card.querySelector('.metric-value');
            value.textContent = formatValue(metric.currentValue);
            
            // Update metric name highlighting
            const name = card.querySelector('.metric-name');
            const { textSearch } = getActiveSearchTerms();
            if (textSearch && metric.name.toLowerCase().includes(textSearch)) {
                name.innerHTML = highlightText(metric.name, textSearch);
            } else {
                name.textContent = metric.name;
            }
            
            // Update labels highlighting
            const labelsContainer = card.querySelector('.metric-labels');
            if (labelsContainer && metric.labels) {
                const newLabelsContainer = createLabelsContainer(metric.labels, key);
                labelsContainer.replaceWith(newLabelsContainer);
            }

            const chartId = `chart-${key.replace(/[^a-zA-Z0-9]/g, '_')}`;
            if (charts.has(chartId)) {
                updateChart(chartId, metric);
            } else {
                // Chart might not exist yet, try to create it
                const canvas = document.getElementById(chartId);
                if (canvas && !charts.has(chartId)) {
                    createChart(chartId, metric);
                }
            }
        }

        function createChart(canvasId, metric) {
            // Check if chart already exists
            if (charts.has(canvasId)) {
                console.warn(`Chart ${canvasId} already exists, updating instead`);
                updateChart(canvasId, metric);
                return;
            }

            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        data: metric.data,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointBackgroundColor: '#667eea',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 1,
                        pointHoverRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: (context) => {
                                    const timestamp = context[0].parsed.x;
                                    return new Date(timestamp).toLocaleTimeString();
                                },
                                label: (context) => `Value: ${formatValue(context.parsed.y)}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            display: true,
                            time: {
                                displayFormats: {
                                    second: 'HH:mm:ss',
                                    minute: 'HH:mm'
                                }
                            },
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxTicksLimit: 4,
                                font: { size: 10 },
                                color: '#999'
                            }
                        },
                        y: {
                            display: true,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            },
                            ticks: {
                                callback: (value) => formatValue(value),
                                maxTicksLimit: 4,
                                font: { size: 10 }
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });

            charts.set(canvasId, chart);
        }

        function updateChart(chartId, metric) {
            const chart = charts.get(chartId);
            if (!chart) return;

            // Update the chart data
            chart.data.datasets[0].data = [...metric.data];
            chart.update();
        }

        function formatValue(value) {
            if (isNaN(value)) return 'NaN';
            if (!isFinite(value)) return value > 0 ? 'Inf' : '-Inf';

            const absValue = Math.abs(value);
            if (absValue >= 1e9) return (value / 1e9).toFixed(2) + 'B';
            if (absValue >= 1e6) return (value / 1e6).toFixed(2) + 'M';
            if (absValue >= 1e3) return (value / 1e3).toFixed(2) + 'K';
            if (absValue < 0.01 && absValue > 0) return value.toExponential(2);
            return value.toFixed(2);
        }

        function filterMetrics() {
            renderMetrics();
        }

        function updateTabCounts(counts) {
            document.querySelectorAll('.tab-button').forEach(button => {
                const tab = button.dataset.tab;
                const count = counts[tab] || 0;
                button.textContent = button.textContent.split(' (')[0] + (count > 0 ? ` (${count})` : '');
            });
        }

        function updateStatus(status, isConnected) {
            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const lastUpdate = document.getElementById('lastUpdate');

            statusText.textContent = status;
            indicator.style.background = isConnected ? '#4caf50' : '#ff5252';
            lastUpdate.textContent = `| Last update: ${new Date().toLocaleTimeString()}`;
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (updateTimer) clearInterval(updateTimer);
            if (countdownTimer) clearInterval(countdownTimer);
            charts.forEach(chart => chart.destroy());
        });
    </script>
</body>
</html>
