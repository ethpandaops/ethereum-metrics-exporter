<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ethereum Metrics Exporter</title>
    <style>
        /* EMBEDDED_CSS */
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.30.0/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>Ethereum Metrics Exporter</h1>
        
        <div class="controls">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Search metrics... (e.g., block, sync, peer)">
                <div class="help-text">Filter metrics by name or labels</div>
            </div>
            <div class="status">
                <span class="status-indicator" id="statusIndicator"></span>
                <span id="statusText">Connecting...</span>
                <span id="lastUpdate"></span>
                <span>| Next update in: <span class="countdown" id="countdown">15s</span></span>
            </div>
        </div>

        <div id="loading" class="loading">Loading metrics...</div>
        <div id="error" class="error" style="display: none;"></div>
        <div id="noData" class="no-data" style="display: none;">No metrics found matching your search.</div>
        <div id="metricsGrid" class="metrics-grid" style="display: none;"></div>
        
        <footer class="footer">
            Powered by üêº <a href="https://github.com/ethpandaops/ethereum-metrics-exporter" target="_blank">ethpandaops/ethereum-metrics-exporter</a>
        </footer>
    </div>

    <script>
        const REFRESH_INTERVAL = 15000; // 15 seconds
        const MAX_DATA_POINTS = 20;
        const metrics = new Map();
        let charts = new Map();
        let updateTimer;
        let countdownTimer;
        let secondsUntilUpdate = 15;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            fetchMetrics();
            startCountdown();
            updateTimer = setInterval(() => {
                fetchMetrics();
                startCountdown();
            }, REFRESH_INTERVAL);
            
            // Search functionality
            document.getElementById('searchInput').addEventListener('input', filterMetrics);
        });

        function startCountdown() {
            secondsUntilUpdate = 15;
            updateCountdownDisplay();
            
            // Clear existing countdown if any
            if (countdownTimer) clearInterval(countdownTimer);
            
            countdownTimer = setInterval(() => {
                secondsUntilUpdate--;
                updateCountdownDisplay();
                
                if (secondsUntilUpdate <= 0) {
                    clearInterval(countdownTimer);
                }
            }, 1000);
        }

        function updateCountdownDisplay() {
            const countdownEl = document.getElementById('countdown');
            if (countdownEl) {
                countdownEl.textContent = `${secondsUntilUpdate}s`;
            }
        }

        async function fetchMetrics() {
            try {
                const response = await fetch('/metrics');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const text = await response.text();
                parseMetrics(text);
                updateStatus('Connected', true);
                renderMetrics();
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'none';
                document.getElementById('metricsGrid').style.display = 'grid';
            } catch (error) {
                console.error('Error fetching metrics:', error);
                updateStatus('Error', false);
                document.getElementById('error').textContent = `Error: ${error.message}`;
                document.getElementById('error').style.display = 'block';
            }
        }

        function parseMetrics(text) {
            const lines = text.split('\n');
            const timestamp = Date.now();
            const currentMetrics = new Set();
            
            for (const line of lines) {
                if (line.startsWith('#') || line.trim() === '') continue;
                
                const match = line.match(/^([a-zA-Z_][a-zA-Z0-9_]*(?:\{[^}]*\})?)\s+([\d\.\+\-eE]+|NaN|Inf|-Inf)$/);
                if (!match) continue;
                
                const [, nameWithLabels, value] = match;
                const labelMatch = nameWithLabels.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\{([^}]*)\}$/);
                
                let metricName, labels;
                if (labelMatch) {
                    metricName = labelMatch[1];
                    labels = labelMatch[2];
                } else {
                    metricName = nameWithLabels;
                    labels = '';
                }
                
                const metricKey = nameWithLabels;
                const numericValue = parseFloat(value);
                currentMetrics.add(metricKey);
                
                if (!metrics.has(metricKey)) {
                    metrics.set(metricKey, {
                        name: metricName,
                        labels: labels,
                        data: [],
                        currentValue: numericValue,
                        lastUpdate: timestamp
                    });
                }
                
                const metric = metrics.get(metricKey);
                metric.currentValue = numericValue;
                
                // Always add a new data point for each fetch
                metric.data.push({ x: timestamp, y: numericValue });
                
                // Keep only last MAX_DATA_POINTS
                if (metric.data.length > MAX_DATA_POINTS) {
                    metric.data.shift();
                }
            }
            
            // Remove metrics that are no longer being reported
            for (const [key] of metrics) {
                if (!currentMetrics.has(key)) {
                    metrics.delete(key);
                }
            }
        }

        function renderMetrics() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const grid = document.getElementById('metricsGrid');
            const visibleMetrics = Array.from(metrics.entries())
                .filter(([key, metric]) => {
                    if (searchTerm === '') return true;
                    return key.toLowerCase().includes(searchTerm) || 
                           metric.labels.toLowerCase().includes(searchTerm);
                })
                .sort((a, b) => a[0].localeCompare(b[0]));
            
            // Show/hide no data message
            document.getElementById('noData').style.display = visibleMetrics.length === 0 ? 'block' : 'none';
            
            visibleMetrics.forEach(([key, metric]) => {
                let card = document.getElementById(`metric-${key.replace(/[^a-zA-Z0-9]/g, '_')}`);
                
                if (!card) {
                    card = createMetricCard(key, metric);
                    grid.appendChild(card);
                } else {
                    updateMetricCard(card, key, metric);
                }
            });
            
            // Remove cards for metrics that are no longer visible
            Array.from(grid.children).forEach(card => {
                const cardKey = card.dataset.metricKey;
                if (!visibleMetrics.find(([key]) => key === cardKey)) {
                    const chartId = `chart-${cardKey.replace(/[^a-zA-Z0-9]/g, '_')}`;
                    if (charts.has(chartId)) {
                        const chart = charts.get(chartId);
                        chart.destroy();
                        charts.delete(chartId);
                    }
                    card.remove();
                }
            });
        }

        function createMetricCard(key, metric) {
            const card = document.createElement('div');
            card.className = 'metric-card';
            card.id = `metric-${key.replace(/[^a-zA-Z0-9]/g, '_')}`;
            card.dataset.metricKey = key;
            
            const header = document.createElement('div');
            header.className = 'metric-header';
            
            const name = document.createElement('div');
            name.className = 'metric-name';
            name.textContent = metric.name;
            
            const value = document.createElement('div');
            value.className = 'metric-value';
            value.textContent = formatValue(metric.currentValue);
            
            header.appendChild(name);
            header.appendChild(value);
            card.appendChild(header);
            
            if (metric.labels) {
                const labels = document.createElement('div');
                labels.className = 'metric-labels';
                labels.textContent = metric.labels;
                card.appendChild(labels);
            }
            
            const chartContainer = document.createElement('div');
            chartContainer.className = 'metric-chart';
            const canvas = document.createElement('canvas');
            canvas.id = `chart-${key.replace(/[^a-zA-Z0-9]/g, '_')}`;
            chartContainer.appendChild(canvas);
            card.appendChild(chartContainer);
            
            // Create chart after adding to DOM
            setTimeout(() => {
                if (!charts.has(canvas.id)) {
                    createChart(canvas.id, metric);
                }
            }, 10);
            
            return card;
        }

        function updateMetricCard(card, key, metric) {
            const value = card.querySelector('.metric-value');
            value.textContent = formatValue(metric.currentValue);
            
            const chartId = `chart-${key.replace(/[^a-zA-Z0-9]/g, '_')}`;
            if (charts.has(chartId)) {
                updateChart(chartId, metric);
            } else {
                // Chart might not exist yet, try to create it
                const canvas = document.getElementById(chartId);
                if (canvas && !charts.has(chartId)) {
                    createChart(chartId, metric);
                }
            }
        }

        function createChart(canvasId, metric) {
            // Check if chart already exists
            if (charts.has(canvasId)) {
                console.warn(`Chart ${canvasId} already exists, updating instead`);
                updateChart(canvasId, metric);
                return;
            }
            
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;
            
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        data: metric.data,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: () => '',
                                label: (context) => formatValue(context.parsed.y)
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            display: false
                        },
                        y: {
                            display: true,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            },
                            ticks: {
                                callback: (value) => formatValue(value),
                                maxTicksLimit: 4,
                                font: { size: 10 }
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
            
            charts.set(canvasId, chart);
        }

        function updateChart(chartId, metric) {
            const chart = charts.get(chartId);
            if (!chart) return;
            
            // Update the chart data
            chart.data.datasets[0].data = [...metric.data];
            chart.update();
        }

        function formatValue(value) {
            if (isNaN(value)) return 'NaN';
            if (!isFinite(value)) return value > 0 ? 'Inf' : '-Inf';
            
            const absValue = Math.abs(value);
            if (absValue >= 1e9) return (value / 1e9).toFixed(2) + 'B';
            if (absValue >= 1e6) return (value / 1e6).toFixed(2) + 'M';
            if (absValue >= 1e3) return (value / 1e3).toFixed(2) + 'K';
            if (absValue < 0.01 && absValue > 0) return value.toExponential(2);
            return value.toFixed(2);
        }

        function filterMetrics() {
            renderMetrics();
        }

        function updateStatus(status, isConnected) {
            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const lastUpdate = document.getElementById('lastUpdate');
            
            statusText.textContent = status;
            indicator.style.background = isConnected ? '#4caf50' : '#ff5252';
            lastUpdate.textContent = `| Last update: ${new Date().toLocaleTimeString()}`;
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (updateTimer) clearInterval(updateTimer);
            if (countdownTimer) clearInterval(countdownTimer);
            charts.forEach(chart => chart.destroy());
        });
    </script>
</body>
</html>